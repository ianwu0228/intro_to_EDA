==============================================================================
File: src/floorplanner.cpp
==============================================================================
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <cmath>
#include <algorithm>
#include <iomanip>
#include "floorplanner.h"

using namespace std;

// 1. Parsing Logic
void Floorplanner::parseInput(fstream &inputFile)
{
    string keyword;

    if (!(inputFile >> keyword) || keyword != "CHIP")
    {
        cerr << "Error: Expected 'CHIP'" << endl;
        exit(1);
    }
    inputFile >> _chipWidth >> _chipHeight;

    int numSoft;
    if (!(inputFile >> keyword) || keyword != "SOFTMODULE")
    {
        cerr << "Error: Expected 'SOFTMODULE'" << endl;
        exit(1);
    }
    inputFile >> numSoft;
    _soft_modules.reserve(numSoft);

    for (int i = 0; i < numSoft; ++i)
    {
        string name;
        size_t area;
        inputFile >> name >> area;
        Block b(name, area);
        b.setID(i);
        _soft_modules.push_back(b);
    }

    // ==========================================
    // NEW: INJECT GHOST BLOCKS
    // ==========================================
    // Configuration: 15% of soft modules, sized at 50% average area
    if (numSoft > 0)
    {
        int numGhosts = static_cast<int>(numSoft * 0.15);

        // Calculate average area
        double totalArea = 0;
        for (const auto &b : _soft_modules)
            totalArea += b.getMinArea();
        size_t avgArea = totalArea / numSoft;
        size_t ghostArea = avgArea / 2;
        if (ghostArea < 1)
            ghostArea = 1; // Safety

        for (int i = 0; i < numGhosts; ++i)
        {
            string name = "GHOST_" + to_string(i);
            // Create ghost block: area, isGhost=true
            Block b(name, ghostArea, true);
            // Assign ID (append to end of list)
            b.setID(numSoft + i);
            _soft_modules.push_back(b);
        }
    }
    // ==========================================

    int numFixed;
    if (!(inputFile >> keyword) || keyword != "FIXEDMODULE")
    {
        cerr << "Error: Expected 'FIXEDMODULE'" << endl;
        exit(1);
    }
    inputFile >> numFixed;
    _fixed_modules.reserve(numFixed);

    for (int i = 0; i < numFixed; ++i)
    {
        string name;
        size_t x, y, w, h;
        inputFile >> name >> x >> y >> w >> h;
        Block b(name, w, h, x, y);
        b.setID(numSoft + i);
        _fixed_modules.push_back(b);
    }

    // Build Map (Wait until vectors are filled so pointers don't invalidate)
    for (auto &b : _soft_modules)
        _name2Terminal[b.getName()] = &b;
    for (auto &b : _fixed_modules)
        _name2Terminal[b.getName()] = &b;

    int numConnections;
    if (!(inputFile >> keyword) || keyword != "CONNECTION")
    {
        cerr << "Error: Expected 'CONNECTION'" << endl;
        exit(1);
    }
    inputFile >> numConnections;

    _net_array.clear();
    for (int i = 0; i < numConnections; ++i)
    {
        string name1, name2;
        int qty;
        inputFile >> name1 >> name2 >> qty;

        Terminal *t1 = _name2Terminal[name1];
        Terminal *t2 = _name2Terminal[name2];

        if (!t1 || !t2)
        {
            cerr << "Error: Unknown module " << name1 << " or " << name2 << endl;
            continue;
        }

        // Create 'qty' nets (Standard HPWL approach)
        for (int k = 0; k < qty; ++k)
        {
            Net net;
            net.setDegree(2);
            net.addTerm(t1);
            net.addTerm(t2);
            _net_array.push_back(net);
        }
    }

    // Initialize Tree with ONLY Soft Blocks
    _tree = new Tree(_soft_modules);

    // Pass the fixed modules to the tree for contour initialization
    _tree->setFixedModules(&_fixed_modules);
}

void Floorplanner::floorplan()
{
    _tree->buildInitial();
    simulatedAnnealing();
}

// 2. Cost Calculation
double Floorplanner::computeArea()
{
    // Current bounding box area of soft modules
    size_t minX = _chipWidth, maxX = 0;
    size_t minY = _chipHeight, maxY = 0;

    if (_soft_modules.empty())
        return 0;

    for (const auto &blk : _soft_modules)
    {
        minX = min(minX, blk.getX1());
        maxX = max(maxX, blk.getX2());
        minY = min(minY, blk.getY1());
        maxY = max(maxY, blk.getY2());
    }
    return (double)(maxX - minX) * (maxY - minY);
}

// double Floorplanner::computeWirelength()
// {
//     double total = 0.0;
//     for (Net &net : _net_array)
//     {
//         total += net.calcHPWL();
//     }
//     return total;
// }

double Floorplanner::computeWirelength()
{
    double total = 0.0;

    // Temporarily apply offsets to blocks for calculation
    for (auto &soft : _soft_modules)
    {
        soft.setPos(soft.getX1() + _offsetX, soft.getY1() + _offsetY,
                    soft.getX2() + _offsetX, soft.getY2() + _offsetY);
    }

    // Calculate HPWL with absolute coordinates
    for (Net &net : _net_array)
    {
        total += net.calcHPWL();
    }

    // Revert offsets (restore relative coordinates for B*-tree packing)
    // Note: B*-tree pack() will overwrite these anyway, but it's good practice.
    for (auto &soft : _soft_modules)
    {
        soft.setPos(soft.getX1() - _offsetX, soft.getY1() - _offsetY,
                    soft.getX2() - _offsetX, soft.getY2() - _offsetY);
    }

    return total;
}

double Floorplanner::computeFixedOverlapPenalty()
{
    double totalOverlap = 0;
    for (const auto &soft : _soft_modules)
    {
        // APPLY OFFSET HERE
        size_t sx1 = soft.getX1() + _offsetX;
        size_t sx2 = soft.getX2() + _offsetX;
        size_t sy1 = soft.getY1() + _offsetY;
        size_t sy2 = soft.getY2() + _offsetY;

        for (const auto &fixed : _fixed_modules)
        {
            // Fixed blocks are absolute, NO offset
            size_t fx1 = fixed.getX1();
            size_t fx2 = fixed.getX2();
            size_t fy1 = fixed.getY1();
            size_t fy2 = fixed.getY2();

            size_t ix1 = max(sx1, fx1);
            size_t ix2 = min(sx2, fx2);
            size_t iy1 = max(sy1, fy1);
            size_t iy2 = min(sy2, fy2);

            if (ix1 < ix2 && iy1 < iy2)
            {
                totalOverlap += (double)(ix2 - ix1) * (iy2 - iy1);
            }
        }
    }
    return totalOverlap;
}

double Floorplanner::computeBoundaryPenalty()
{
    double totalViolation = 0;
    for (const auto &soft : _soft_modules)
    {
        // APPLY OFFSET HERE
        size_t sx2 = soft.getX2() + _offsetX;
        size_t sy2 = soft.getY2() + _offsetY;

        // Check violations
        if (sx2 > _chipWidth)
            totalViolation += (sx2 - _chipWidth) * soft.getHeight();
        if (sy2 > _chipHeight)
            totalViolation += (sy2 - _chipHeight) * soft.getWidth();
        // Also check if offset pushed it negative (though we clamped it to 0 above)
    }
    return totalViolation;
}

double Floorplanner::computeCost()
{
    double W = computeWirelength();
    double Area = computeArea(); // Optional, but usually good to keep area tight
    double Boundary = computeBoundaryPenalty();
    double Overlap = computeFixedOverlapPenalty();

    // Avoid division by zero
    double nW = (_normWL > 0) ? _normWL : 1.0;
    double nA = (_normArea > 0) ? _normArea : 1.0;
    double nB = (_normBoundary > 0) ? _normBoundary : 1.0;
    double nO = (_normOverlap > 0) ? _normOverlap : 1.0;

    // Cost = alpha*Area + (1-alpha)*WL + Penalties
    // Note: The contest only cares about WL, but during annealing we need Area to guide packing.
    // _gamma and _delta should be very large.

    return _alpha * (Area / nA) + (1.0 - _alpha) * (W / nW) + _gamma * (Boundary / nB) + _delta * (Overlap / nO);
}

void Floorplanner::computeNormalizationFactors(double &areaNorm, double &wlNorm,
                                               double &boundaryNorm, double &overlapNorm, int sampleSize)
{
    double totalArea = 0, totalWL = 0, totalBound = 0, totalOverlap = 0;

    for (int i = 0; i < sampleSize; ++i)
    {
        _tree->rotateRandom();
        _tree->deleteAndInsert();
        _tree->resizeRandom(); // Don't forget resize!
        _tree->pack();

        totalArea += computeArea();
        totalWL += computeWirelength();
        totalBound += computeBoundaryPenalty();
        totalOverlap += computeFixedOverlapPenalty();
    }

    areaNorm = totalArea / sampleSize;
    wlNorm = totalWL / sampleSize;
    // Add small epsilon to avoid zero
    boundaryNorm = (totalBound / sampleSize) + 1.0;
    overlapNorm = (totalOverlap / sampleSize) + 1.0;
}

// 3. Simulated Annealing
void Floorplanner::simulatedAnnealing()
{
    double T = 10000.0;
    const double T_min = 0.1;
    const double cooling_rate = 0.98;
    const int iterations = 500; // Increase for better quality

    // Normalization
    computeNormalizationFactors(_normArea, _normWL, _normBoundary, _normOverlap, 50);

    _tree->pack();
    double prevCost = computeCost();
    double bestCost = prevCost;

    // We must save the "best state". Since Tree holds pointers to _soft_modules,
    // we need to save the Tree structure AND the Block dimensions (because resize changes them).
    Tree bestTree = *_tree;
    vector<Block> bestBlocks = _soft_modules; // Save block states (dims)

    while (T > T_min)
    {
        for (int i = 0; i < iterations; ++i)
        {
            Tree backupTree = *_tree;
            vector<Block> backupBlocks = _soft_modules; // Expensive copy, optimize later if needed

            double oldCost = prevCost;

            // Perturb
            double r = (double)rand() / RAND_MAX;

            // Backup offsets
            int backupX = _offsetX;
            int backupY = _offsetY;

            if (r < 0.1)
                _tree->resizeRandom();
            else if (r < 0.3)
                _tree->rotateRandom();
            else if (r < 0.5)
                _tree->swapRandomNodes();
            else if (r < 0.7)
                _tree->deleteAndInsert();
            else
                moveCluster();

            _tree->pack();
            double newCost = computeCost();
            double delta = newCost - oldCost;

            bool accept = (delta < 0) || ((double)rand() / RAND_MAX < exp(-delta / T));

            if (accept)
            {
                prevCost = newCost;
                if (newCost < bestCost)
                {
                    bestCost = newCost;
                    bestTree = *_tree;
                    bestBlocks = _soft_modules;
                }
            }
            else
            {
                _offsetX = backupX; // Restore offset if rejected
                _offsetY = backupY;
                *_tree = backupTree;
                _soft_modules = backupBlocks; // Restore dimensions
            }
        }
        T *= cooling_rate;
    }

    // Restore Best
    *_tree = bestTree;
    _soft_modules = bestBlocks;
    _tree->pack();
    outputWirelength = (size_t)computeWirelength();
}

// // 4. Output Logic (ICCAD Format)
// void Floorplanner::outputResults(fstream &outputFile, double runtime)
// {
//     // ICCAD Format:
//     // HPWL <value>
//     // SOFTMODULE <num>
//     // <name> <num_corners>
//     // <x> <y> ... (corners)

//     // We strictly output rectangles (4 corners) for soft modules

//     outputFile << "HPWL " << fixed << setprecision(1) << (double)outputWirelength << endl;

//     outputFile << "SOFTMODULE " << _soft_modules.size() << endl;
//     for (const auto &b : _soft_modules)
//     {
//         outputFile << b.getName() << " 4" << endl;
//         // Output 4 corners clockwise starting from bottom-left?
//         // Contest usually accepts: (x1,y1) (x1,y2) (x2,y2) (x2,y1)
//         // Check strict contest rules. Assuming standard rectangle output:
//         outputFile << b.getX1() << " " << b.getY1() << endl;
//         outputFile << b.getX1() << " " << b.getY2() << endl;
//         outputFile << b.getX2() << " " << b.getY2() << endl;
//         outputFile << b.getX2() << " " << b.getY1() << endl;
//     }
// }

// void Floorplanner::outputResults(fstream &outputFile, double runtime)
// {
//     // 1. Ensure the tree is packed one last time to get clean relative coordinates
//     _tree->pack();

//     // 2. Output Header
//     // "HPWL <value>" (Precision to 1 decimal place)
//     // Note: We re-calculate HPWL here to ensure it includes the final offsets
//     double finalHPWL = computeWirelength();
//     outputFile << "HPWL " << fixed << setprecision(1) << finalHPWL << endl;

//     // 3. Output Soft Modules
//     // "SOFTMODULE <number>"
//     outputFile << "SOFTMODULE " << _soft_modules.size() << endl;

//     for (const auto &b : _soft_modules)
//     {
//         // Format: <Name> <NumCorners>
//         outputFile << b.getName() << " 4" << endl;

//         // Apply the global Cluster Offset to get absolute coordinates
//         size_t x1 = b.getX1() + _offsetX;
//         size_t y1 = b.getY1() + _offsetY;
//         size_t x2 = b.getX2() + _offsetX;
//         size_t y2 = b.getY2() + _offsetY;

//         //[cite_start] // Output 4 corners in CLOCKWISE order (starting Bottom-Left) [cite: 250]
//         // 1. Bottom-Left
//         outputFile << x1 << " " << y1 << endl;
//         // 2. Top-Left
//         outputFile << x1 << " " << y2 << endl;
//         // 3. Top-Right
//         outputFile << x2 << " " << y2 << endl;
//         // 4. Bottom-Right
//         outputFile << x2 << " " << y1 << endl;
//     }
// }

void Floorplanner::outputResults(fstream &outputFile, double runtime)
{
    // 1. Ensure the tree is packed one last time
    _tree->pack();

    // 2. Output Header
    double finalHPWL = computeWirelength();
    outputFile << "HPWL " << fixed << setprecision(1) << finalHPWL << endl;

    // NEW: Calculate REAL module count (exclude ghosts)
    size_t realCount = 0;
    for (const auto &b : _soft_modules)
    {
        if (!b.isGhost())
            realCount++;
    }

    outputFile << "SOFTMODULE " << realCount << endl;

    for (const auto &b : _soft_modules)
    {
        // NEW: Skip ghost blocks
        if (b.isGhost())
            continue;

        // Format: <Name> <NumCorners>
        outputFile << b.getName() << " 4" << endl;

        // Apply global Cluster Offset
        size_t x1 = b.getX1() + _offsetX;
        size_t y1 = b.getY1() + _offsetY;
        size_t x2 = b.getX2() + _offsetX;
        size_t y2 = b.getY2() + _offsetY;

        // Output 4 corners in CLOCKWISE order (starting Bottom-Left)
        outputFile << x1 << " " << y1 << endl;
        outputFile << x1 << " " << y2 << endl;
        outputFile << x2 << " " << y2 << endl;
        outputFile << x2 << " " << y1 << endl;
    }
}

// Add this new function
void Floorplanner::moveCluster()
{
    // Move the cluster randomly within the chip range
    // We can shift by large amounts or small deltas.
    // For simplicity, let's pick a random valid coordinate occasionally,
    // or drift it slightly.

    // Random drift: -100 to +100 units
    int driftX = (rand() % 200) - 100;
    int driftY = (rand() % 200) - 100;

    _offsetX += driftX;
    _offsetY += driftY;

    // Keep it somewhat sane (optional, but helps convergence)
    if (_offsetX < 0)
        _offsetX = 0;
    if (_offsetY < 0)
        _offsetY = 0;
    if (_offsetX > (int)_chipWidth)
        _offsetX = _chipWidth;
    if (_offsetY > (int)_chipHeight)
        _offsetY = _chipHeight;
}


==============================================================================
File: src/floorplanner.h
==============================================================================
#ifndef FLOORPLANNER_H
#define FLOORPLANNER_H

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <unordered_map>
#include "module.h"
#include "node.h"
#include "tree.h"

using namespace std;

class Floorplanner
{
public:
    // Constructor
    Floorplanner(fstream &inputFile, double alpha)
    {
        _alpha = alpha;
        parseInput(inputFile);
    }

    // Main routine
    void floorplan();

    // Data Members
    double _alpha;          // Weight for Area vs Wirelength
    double _beta = 0.5;     // Weight for Aspect Ratio penalty
    double _gamma = 1000.0; // Weight for Boundary penalty
    double _delta = 1000.0; // Weight for Fixed Overlap penalty

    size_t _chipWidth;  // Fixed Outline Width (from CHIP)
    size_t _chipHeight; // Fixed Outline Height (from CHIP)

    // for the whole softblocks offset
    int _offsetX = 0;
    int _offsetY = 0;

    // Separate vectors for Soft and Fixed modules
    vector<Block> _soft_modules;
    vector<Block> _fixed_modules;
    vector<Net> _net_array;

    unordered_map<string, Terminal *> _name2Terminal;

    Tree *_tree;

    // Parsing
    void parseInput(fstream &inputFile);

    // Output results
    size_t getOutputWirelength() const { return outputWirelength; }
    void outputResults(fstream &outputFile, double runtime);

    // Optimization & Cost
    void simulatedAnnealing(); // Added this!

    double computeWirelength();
    double computeArea(); // Added this!
    double computeCost(); // Signature updated to take no args

    // Helper to calculate normalization factors
    void computeNormalizationFactors(double &areaNorm, double &wlNorm,
                                     double &boundaryNorm, double &overlapNorm,
                                     int sampleSize);

    // Penalties
    double computeFixedOverlapPenalty();
    double computeBoundaryPenalty();

    void moveCluster();

private:
    size_t outputWirelength;
    double _normWL = 1.0;
    double _normArea = 1.0;
    double _normBoundary = 1.0;
    double _normOverlap = 1.0;
};

#endif // FLOORPLANNER_H


==============================================================================
File: src/main.cpp
==============================================================================
// main.cpp

#include <iostream>
#include <fstream>
#include <vector>
#include <ctime>
#include <cstdlib>
#include <chrono>

#include "floorplanner.h"

using namespace std;

// usage
// deafault:
// python3 visualize.py input_case1.txt output_case1.txt
// specify file name:
// python3 visualize.py input_case1.txt output_case1.txt -o my_floorplan.png

int main(int argc, char **argv)
{
    srand(static_cast<unsigned int>(time(0)));
    fstream input_file, output;
    double alpha = 0.5; // Default alpha

    // ICCAD Format: ./fp [input_file] [output_file]
    // Or your Makefile format: ./fp [alpha] [input] [output] (Let's support your Makefile format)

    if (argc == 4)
    {
        cout << "Makefile Format Detected." << endl;
        // format: ./fp <alpha> <input> <output>
        alpha = stod(argv[1]);
        input_file.open(argv[2], ios::in);
        output.open(argv[3], ios::out);

        if (!input_file)
        {
            cerr << "Cannot open input file: " << argv[2] << endl;
            exit(1);
        }
        if (!output)
        {
            cerr << "Cannot open output file: " << argv[3] << endl;
            exit(1);
        }
    }
    // ICCAD Contest format often uses: ./binary input output
    else if (argc == 3)
    {
        cout << "ICCAD Format Detected." << endl;
        input_file.open(argv[1], ios::in);
        output.open(argv[2], ios::out);
        alpha = 0; // Default if not provided
    }
    else
    {
        cerr << "Usage: ./Floorplanner <alpha> <input file> <output file>" << endl;
        exit(1);
    }

    // New Constructor: Single input file
    Floorplanner *fp = new Floorplanner(input_file, alpha);
    cout << "Floorplanner initialized with alpha = " << alpha << endl;

    // Start timing
    auto start_time = chrono::high_resolution_clock::now();

    fp->floorplan();

    // End timing
    auto end_time = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::milliseconds>(end_time - start_time);

    cout << "Time taken: " << duration.count() * 0.001 << " s" << endl;

    // Output results
    fp->outputResults(output, duration.count() * 0.001);

    return 0;
}


==============================================================================
File: src/module.h
==============================================================================
#ifndef MODULE_H
#define MODULE_H

#include <vector>
#include <string>
#include <algorithm> // for std::max, std::min
#include <cmath>     // for std::sqrt
#include <limits>
#include "node.h" // Node

using namespace std;

class Terminal
{
public:
    // constructor and destructor
    Terminal(string &name, size_t x, size_t y) : _name(name), _x1(x), _y1(y), _x2(x), _y2(y) {}
    virtual ~Terminal() {} // Virtual destructor is safer for inheritance

    // basic access methods
    string getName() const { return _name; } // Added const
    size_t getX1() const { return _x1; }
    size_t getX2() const { return _x2; }
    size_t getY1() const { return _y1; }
    size_t getY2() const { return _y2; }

    // Center coordinates for HPWL calculation
    size_t getCenterX() const { return (_x1 + _x2) / 2; }
    size_t getCenterY() const { return (_y1 + _y2) / 2; }

    // set functions
    void setName(string &name) { _name = name; }
    void setPos(size_t x1, size_t y1, size_t x2, size_t y2)
    {
        _x1 = x1;
        _y1 = y1;
        _x2 = x2;
        _y2 = y2;
    }
    void setID(size_t id) { _id = id; }

protected:
    string _name; // module name
    size_t _x1;   // min x coordinate of the terminal
    size_t _y1;   // min y coordinate of the terminal
    size_t _x2;   // max x coordinate of the terminal
    size_t _y2;   // max y coordinate of the terminal
    size_t _id;
};

// class Block : public Terminal
// {
// public:
//     // Constructor for SOFT modules (Area is known, Dimensions flexible)
//     Block(string &name, size_t minArea) : Terminal(name, 0, 0), _minArea(minArea), _isFixed(false)
//     {
//         // Default to square shape initially
//         _w = static_cast<size_t>(sqrt(minArea));
//         _h = _w;
//         if (_w * _h < _minArea)
//             _h++; // Ensure area constraint
//     }

//     // Constructor for FIXED modules (Dimensions and Position known)
//     Block(string &name, size_t w, size_t h, size_t x, size_t y) : Terminal(name, x, y), _w(w), _h(h), _minArea(w * h), _isFixed(true)
//     {
//         _x2 = _x1 + _w;
//         _y2 = _y1 + _h;
//     }

//     ~Block() {}

//     // basic access methods
//     size_t getWidth(bool rotate = false) const { return rotate ? _h : _w; }
//     size_t getHeight(bool rotate = false) const { return rotate ? _w : _h; }
//     size_t getArea() const { return _h * _w; }
//     size_t getMinArea() const { return _minArea; }
//     bool isFixed() const { return _isFixed; }

//     // set functions
//     void setWidth(size_t w) { _w = w; }
//     void setHeight(size_t h) { _h = h; }
//     void setID(size_t id) { _id = id; }

//     // Resize function for Soft Modules (Aspect Ratio = H / W)
//     void resize(double aspectRatio)
//     {
//         if (_isFixed)
//             return;

//         // Calculate W based on Area and AR: W = sqrt(Area / AR)
//         _w = static_cast<size_t>(std::sqrt(_minArea / aspectRatio));
//         // Calculate H based on W
//         if (_w == 0)
//             _w = 1; // Prevent div by zero
//         _h = static_cast<size_t>(std::ceil((double)_minArea / _w));

//         // Double check area constraint (integer math can be tricky)
//         if (_w * _h < _minArea)
//             _h++;
//     }

//     // other member functions
//     void setNode(Node *node) { _node = node; }
//     Node *getNode() { return _node; }

// private:
//     size_t _w;       // width of the block
//     size_t _h;       // height of the block
//     size_t _minArea; // NEW: Required minimum area
//     bool _isFixed;   // NEW: Flag for fixed modules
//     size_t _id;      // id of the block
//     Node *_node;     // pointer to the parent node
// };

class Block : public Terminal
{
public:
    // Constructor for SOFT modules (Area is known, Dimensions flexible)
    // ADDED: isGhost parameter (defaults to false)
    Block(string &name, size_t minArea, bool isGhost = false)
        : Terminal(name, 0, 0), _minArea(minArea), _isFixed(false), _isGhost(isGhost)
    {
        _w = static_cast<size_t>(sqrt(minArea));
        _h = _w;
        if (_w * _h < _minArea)
            _h++;
    }

    // Constructor for FIXED modules (Dimensions and Position known)
    Block(string &name, size_t w, size_t h, size_t x, size_t y)
        : Terminal(name, x, y), _w(w), _h(h), _minArea(w * h), _isFixed(true), _isGhost(false)
    {
        _x2 = _x1 + _w;
        _y2 = _y1 + _h;
    }

    ~Block() {}

    // basic access methods
    size_t getWidth(bool rotate = false) const { return rotate ? _h : _w; }
    size_t getHeight(bool rotate = false) const { return rotate ? _w : _h; }
    size_t getArea() const { return _h * _w; }
    size_t getMinArea() const { return _minArea; }
    bool isFixed() const { return _isFixed; }

    // NEW: Ghost getter
    bool isGhost() const { return _isGhost; }

    // set functions
    void setWidth(size_t w) { _w = w; }
    void setHeight(size_t h) { _h = h; }
    void setID(size_t id) { _id = id; }

    // Resize function for Soft Modules (Aspect Ratio = H / W)
    void resize(double aspectRatio)
    {
        if (_isFixed)
            return;

        // Safety check for ghosts with very small area
        if (_minArea == 0)
            return;

        _w = static_cast<size_t>(std::sqrt(_minArea / aspectRatio));
        if (_w == 0)
            _w = 1;
        _h = static_cast<size_t>(std::ceil((double)_minArea / _w));

        if (_w * _h < _minArea)
            _h++;
    }

    void setNode(Node *node) { _node = node; }
    Node *getNode() { return _node; }

private:
    size_t _w;
    size_t _h;
    size_t _minArea;
    bool _isFixed;
    bool _isGhost; // NEW: Ghost flag
    size_t _id;
    Node *_node;
};

class Net
{
public:
    Net() {}
    ~Net() {}

    const vector<Terminal *> getTermList() { return _termList; }
    size_t getDegree() { return _netDegree; }

    void addTerm(Terminal *term) { _termList.push_back(term); }
    void setDegree(size_t degree) { _netDegree = degree; }

    // Updated HPWL Calculation (Center-to-Center)
    // The problem statement specifies center-to-center distance for Manhattan distance
    double calcHPWL() const
    {
        if (_termList.empty())
            return 0.0;

        size_t minX = std::numeric_limits<size_t>::max();
        size_t maxX = 0;
        size_t minY = std::numeric_limits<size_t>::max();
        size_t maxY = 0;

        for (Terminal *term : _termList)
        {
            size_t cx = term->getCenterX();
            size_t cy = term->getCenterY();

            minX = std::min(minX, cx);
            maxX = std::max(maxX, cx);
            minY = std::min(minY, cy);
            maxY = std::max(maxY, cy);
        }

        return static_cast<double>((maxX - minX) + (maxY - minY));
    }

private:
    vector<Terminal *> _termList;
    size_t _netDegree;
};

#endif // MODULE_H


==============================================================================
File: src/node.h
==============================================================================
#ifndef NODE_H
#define NODE_H

using namespace std;

class Node
{
public:
    // Constructor
    Node(int id)
        : _id(id), _rotated(false),
          _parent(nullptr), _left(nullptr), _right(nullptr) {}

    // Getters
    int   getBlockIndex() const    { return _id; }
    bool  isRotated()     const    { return _rotated;    }
    Node* getParent()     const    { return _parent;     }
    Node* getLeft()       const    { return _left;       }
    Node* getRight()      const    { return _right;      }

    // Setters
    void setBlockIndex(int idx) { _id = idx;  }
    void setRotated(bool r)     { _rotated = r;       }
    void setParent(Node* p)     { _parent = p;        }
    void setLeft(Node* l)       { _left = l;          }
    void setRight(Node* r)      { _right = r;         }

private:
    int   _id;  // Index referring to a block in the Floorplanner's block array
    bool  _rotated;     // True if this node’s block is rotated
    Node* _parent;      // Pointer to the parent node
    Node* _left;        // Pointer to the left child
    Node* _right;       // Pointer to the right child
};

#endif // NODE_H



==============================================================================
File: src/tree.cpp
==============================================================================
#include "tree.h"
#include <iostream>
#include <cstdlib> // for rand()
#include <vector>
#include <algorithm> // for std::random_shuffle
#include <ctime>     // for std::time
#include <cmath>     // for std::abs
#include <fstream>

using namespace std;

// void Tree::buildInitial()
// {
//     if (_blocks.empty()) return;

//     // Clear just in case
//     _nodes.clear();
//     _nodes.reserve(_blocks.size());

//     // Create one node per block
//     for (size_t i = 0; i < _blocks.size(); ++i) {
//         _nodes.emplace_back(i);                          // Node with block ID
//         _blocks[i].setNode(&_nodes.back());              // Point Block -> Node
//     }

//     // Build left-linked chain: node[i] is the left child of node[i - 1]
//     _root = &_nodes[0];          // Set first node as root
//     _root->setParent(nullptr);

//     for (size_t i = 1; i < _nodes.size()/2; ++i) {
//         Node* parent = &_nodes[i - 1];
//         Node* child  = &_nodes[i];

//         parent->setLeft(child);      // B*-tree: left = rightward placement
//         child->setParent(parent);
//     }
//     for (size_t i = _nodes.size()/2; i < _nodes.size(); ++i) {
//         Node* parent = &_nodes[i - 1];
//         Node* child  = &_nodes[i];

//         parent->setRight(child);      // B*-tree: left = rightward placement
//         child->setParent(parent);
//     }
// }

// tree.cpp

// void Tree::resizeRandom()
// {
//     if (_blocks.empty())
//         return;

//     // Pick a random block
//     int randIdx = rand() % _blocks.size();

//     // We must ensure we don't try to resize a Fixed block (though _blocks should only contain soft ones now)
//     // But double check just in case:
//     if (_blocks[randIdx].isFixed())
//         return;

//     // Generate random Aspect Ratio between 0.5 and 2.0
//     // (rand / RAND_MAX) gives 0.0 to 1.0
//     // formula: 0.5 + (0..1.5)
//     double ar = 0.5 + (static_cast<double>(rand()) / RAND_MAX) * 1.5;

//     _blocks[randIdx].resize(ar);
// }

// void Tree::resizeRandom()
// {
//     if (_blocks.empty())
//         return;

//     // Pick a random block
//     int randIdx = rand() % _blocks.size();

//     // Check if fixed
//     if (_blocks[randIdx].isFixed())
//         return;

//     double ar;
//     // NEW: Different Aspect Ratio range for Ghosts
//     if (_blocks[randIdx].isGhost())
//     {
//         // Allow ghosts to range from 0.1 to 10.0 (very thin/wide)
//         ar = 0.1 + (static_cast<double>(rand()) / RAND_MAX) * 9.9;
//     }
//     else
//     {
//         // Standard range for modules (0.5 to 2.0)
//         ar = 0.5 + (static_cast<double>(rand()) / RAND_MAX) * 1.5;
//     }

//     _blocks[randIdx].resize(ar);
// }

void Tree::resizeRandom()
{
    if (_blocks.empty())
        return;

    int randIdx = rand() % _blocks.size();

    // Skip fixed blocks
    if (_blocks[randIdx].isFixed())
        return;

    Block &blk = _blocks[randIdx];

    // LOGIC FOR GHOST BLOCKS
    if (blk.isGhost())
    {
        // 50% chance to become ACTIVE (Spacer)
        // 50% chance to become INACTIVE (Zero Size)
        double choice = (double)rand() / RAND_MAX;

        if (choice < 0.5)
        {
            // BECOME INACTIVE (effectively delete)
            blk.setWidth(0);
            blk.setHeight(0);
        }
        else
        {
            // BECOME ACTIVE (restore/resize)
            // Generate a random skinny/flat aspect ratio
            double ar = 0.1 + ((double)rand() / RAND_MAX) * 9.9;

            // This function uses _minArea to recalculate Width and Height
            // effectively "Resurrecting" the ghost if it was previously 0
            blk.resize(ar);
        }
    }
    // LOGIC FOR REAL SOFT MODULES
    else
    {
        // Standard aspect ratio resize (0.5 to 2.0)
        double ar = 0.5 + ((double)rand() / RAND_MAX) * 1.5;
        blk.resize(ar);
    }
}

void Tree::buildInitial()
{
    if (_blocks.empty())
        return;

    // Clear just in case
    _nodes.clear();
    _nodes.reserve(_blocks.size());

    // Create one node per block
    for (size_t i = 0; i < _blocks.size(); ++i)
    {
        _nodes.emplace_back(i);             // Node with block ID
        _blocks[i].setNode(&_nodes.back()); // Point Block -> Node
    }

    // Build complete binary tree
    _root = &_nodes[0]; // Set first node as root
    _root->setParent(nullptr);

    for (size_t i = 0; i < _nodes.size(); ++i)
    {
        // Calculate indices of left and right children
        size_t leftIdx = 2 * i + 1;
        size_t rightIdx = 2 * i + 2;

        // Set left child if exists
        if (leftIdx < _nodes.size())
        {
            _nodes[i].setLeft(&_nodes[leftIdx]);
            _nodes[leftIdx].setParent(&_nodes[i]);
        }

        // Set right child if exists
        if (rightIdx < _nodes.size())
        {
            _nodes[i].setRight(&_nodes[rightIdx]);
            _nodes[rightIdx].setParent(&_nodes[i]);
        }
    }
}

// void Tree::buildInitial() {
//     if (_blocks.empty()) return;

//     _nodes.clear();
//     _nodes.reserve(_blocks.size());

//     // 1. Create nodes
//     for (size_t i = 0; i < _blocks.size(); ++i) {
//         _nodes.emplace_back(i);
//         _blocks[i].setNode(&_nodes.back());
//     }

//     // 2. Build balanced tree recursively
//     _root = buildBalancedRecursive(0, _nodes.size() - 1);
// }

// Node* Tree::buildBalancedRecursive(int l, int r) {
//     if (l > r) return nullptr;

//     int mid = (l + r) / 2;
//     Node* root = &_nodes[mid];

//     Node* leftChild = buildBalancedRecursive(l, mid - 1);
//     Node* rightChild = buildBalancedRecursive(mid + 1, r);

//     root->setLeft(leftChild);
//     root->setRight(rightChild);

//     if (leftChild) leftChild->setParent(root);
//     if (rightChild) rightChild->setParent(root);

//     return root;
// }

void Tree::rotateRandom()
{
    // Randomly rotate a node in the tree
    if (_nodes.empty())
        return;
    // Select a random node index
    size_t randomIndex = rand() % _nodes.size();
    Node *randomNode = &_nodes[randomIndex];

    // Toggle rotation state
    randomNode->setRotated(!randomNode->isRotated());
}

void Tree::deleteNode(Node *u)
{
    if (!u)
        return;

    Node *parent = u->getParent();
    Node *left = u->getLeft();
    Node *right = u->getRight();

    // Case 1: no children
    if (!left && !right)
    {
        if (parent)
        {
            if (parent->getLeft() == u)
                parent->setLeft(nullptr);
            else if (parent->getRight() == u)
                parent->setRight(nullptr);
        }
        else
        {
            _root = nullptr; // u is root
            cout << "error: root is deleted with no children" << endl;
        }
        u->setLeft(nullptr);
        u->setRight(nullptr);
        u->setParent(nullptr); // Disconnect from parent
        return;
    }

    // Case 2: only one child
    Node *child = left ? left : right;
    if (!left || !right)
    {
        if (parent)
        {
            if (parent->getLeft() == u)
                parent->setLeft(child);
            else
                parent->setRight(child);
        }
        else
        {
            _root = child;
        }
        child->setParent(parent);
        u->setLeft(nullptr);
        u->setRight(nullptr);
        u->setParent(nullptr); // Disconnect from parent
        return;
    }

    // Case 3: two children
    // Promote left, and attach right at rightmost of left's right spine
    Node *newChild = left;

    // Attach right subtree to rightmost node of left subtree
    Node *rightmost = left;
    while (rightmost->getRight())
    {
        rightmost = rightmost->getRight();
    }
    rightmost->setRight(right);
    right->setParent(rightmost);

    // Reconnect to parent
    if (parent)
    {
        if (parent->getLeft() == u)
            parent->setLeft(newChild);
        else
            parent->setRight(newChild);
    }
    else
    {
        _root = newChild;
    }
    newChild->setParent(parent);
    u->setLeft(nullptr);
    u->setRight(nullptr);
    u->setParent(nullptr); // Disconnect from parent
}

// void Tree::deleteNode(Node* u)
// {
//     if (!u) return;

//     Node* parent = u->getParent();
//     Node* left   = u->getLeft();
//     Node* right  = u->getRight();

//     // Case 1: no children
//     if (!left && !right) {
//         if (parent) {
//             if (parent->getLeft() == u) parent->setLeft(nullptr);
//             else if (parent->getRight() == u) parent->setRight(nullptr);
//         } else {
//             _root = nullptr; // u was root
//         }
//     }

//     // Case 2: one child
//     else if (!left || !right) {
//         Node* child = left ? left : right;
//         if (parent) {
//             if (parent->getLeft() == u) parent->setLeft(child);
//             else parent->setRight(child);
//         } else {
//             _root = child;  // u was root
//         }
//         child->setParent(parent);
//     }

//     // Case 3: two children
//     else {
//         // Promote left
//         Node* newSubtree = left;

//         // Attach right subtree to the rightmost node of left
//         Node* rightmost = left;
//         while (rightmost->getRight()) {
//             rightmost = rightmost->getRight();
//         }
//         rightmost->setRight(right);
//         right->setParent(rightmost);

//         if (parent) {
//             if (parent->getLeft() == u) parent->setLeft(newSubtree);
//             else parent->setRight(newSubtree);
//         } else {
//             _root = newSubtree;
//         }
//         newSubtree->setParent(parent);
//     }

//     // Clear u
//     u->setLeft(nullptr);
//     u->setRight(nullptr);
//     u->setParent(nullptr);
// }

void Tree::insertNode(Node *u, Node *target, bool asLeftChild)
{
    if (!u || !target)
    {
        cout << "error: null pointer in insertNode" << endl;
        return;
    }

    // Set parent of u to target
    u->setParent(target);

    // Set left/right child of target to u
    if (asLeftChild)
    {
        target->setLeft(u);
    }
    else
    {
        target->setRight(u);
    }
}

void Tree::deleteAndInsert()
{
    if (_nodes.size() <= 1)
        return;

    // Step 1: select a random node to delete (not root is safer)
    Node *u;
    // do {
    //     u = &_nodes[rand() % _nodes.size()];
    // } while (u == _root);  // Avoid deleting root for now
    u = &_nodes[rand() % _nodes.size()];

    deleteNode(u);

    // Step 2: build a list of valid insertion targets
    vector<Node *> candidates;
    for (Node &n : _nodes)
    {
        if (&n == u)
            continue;
        if (n.getLeft() == nullptr || n.getRight() == nullptr)
            candidates.push_back(&n);
    }

    if (candidates.empty())
        return; // No valid place to reinsert

    // Step 3: pick one and insert u as child
    Node *target = candidates[rand() % candidates.size()];
    bool asLeft;
    if (target->getLeft() == nullptr && target->getRight() == nullptr)
    {
        // both available — pick randomly
        asLeft = rand() % 2;
        // asLeft = true;
    }
    else if (target->getLeft() == nullptr)
    {
        asLeft = true;
    }
    else if (target->getRight() == nullptr)
    {
        asLeft = false;
    }
    else
    {
        // no slot available — skip or pick a new target
        return;
    }
    insertNode(u, target, asLeft);
}

// void Tree::deleteAndInsert()
// {
//     if (_nodes.size() <= 1) return;

//     Node* u = nullptr;
//     // Pick node to delete (allow root now)
//     u = &_nodes[rand() % _nodes.size()];

//     deleteNode(u);  // May update _root

//     // Gather valid insert positions
//     vector<Node*> candidates;
//     for (Node& n : _nodes) {
//         if (&n == u) continue;
//         if (n.getLeft() == nullptr || n.getRight() == nullptr)
//             candidates.push_back(&n);
//     }

//     if (candidates.empty()) return;

//     Node* target = candidates[rand() % candidates.size()];

//     bool asLeft;
//     if (target->getLeft() == nullptr && target->getRight() == nullptr) {
//         asLeft = rand() % 2;
//     } else if (target->getLeft() == nullptr) {
//         asLeft = true;
//     } else if (target->getRight() == nullptr) {
//         asLeft = false;
//     } else {
//         return;
//     }

//     insertNode(u, target, asLeft);
// }

// void Tree::swapRandomNodes()
// {
//     if (_nodes.size() <= 1) return;

//     Node* u;
//     Node* v;

//     do {
//         u = &_nodes[rand() % _nodes.size()];
//         v = &_nodes[rand() % _nodes.size()];
//     } while (u == v);  // allow root swap if you handle _root properly

//     ////////////// conditions //////////////
//     // make sure u and v are not direct parent-child
//     if (u == v->getParent() || v == u->getParent()) return;
//     // make sure they don't share the same parent
//     if ((u->getParent() == v->getParent())) return;
//     // make sure they are not in the same subtree
//     if (isDescendant(u, v) || isDescendant(v, u)) return;
//     //////////////// end conditions //////////////

//     // Save neighbors
//     Node* pu = u->getParent();
//     Node* pl = u->getLeft();
//     Node* pr = u->getRight();

//     Node* qv = v->getParent();
//     Node* ql = v->getLeft();
//     Node* qr = v->getRight();

//     // Swap parents
//     u->setParent(qv);
//     v->setParent(pu);

//     // Swap children
//     u->setLeft(ql);
//     u->setRight(qr);
//     v->setLeft(pl);
//     v->setRight(pr);

//     // Fix parents’ child pointers
//     if (qv) {
//         if (qv->getLeft() == v) qv->setLeft(u);
//         else if (qv->getRight() == v) qv->setRight(u);
//     } else {
//         _root = u;  // v was root
//     }

//     if (pu) {
//         if (pu->getLeft() == u) pu->setLeft(v);
//         else if (pu->getRight() == u) pu->setRight(v);
//     } else {
//         _root = v;  // u was root
//     }

//     // Fix children’s parent pointers
//     if (ql) ql->setParent(u);
//     if (qr) qr->setParent(u);
//     if (pl) pl->setParent(v);
//     if (pr) pr->setParent(v);

// }

void Tree::swapRandomNodes()
{
    if (_nodes.size() <= 1)
        return;

    Node *u;
    Node *v;

    do
    {
        u = &_nodes[rand() % _nodes.size()];
        v = &_nodes[rand() % _nodes.size()];
    } while (u == v); // allow root swap if you handle _root properly

    //////////////// handle special cases

    // if u and v are parent-child
    //  make sure u and v are not direct parent-child
    if (u == v->getParent() || v == u->getParent())
    {
        if (u == v->getParent())
        {
            // Case: u is parent of v → promote v, demote u

            Node *grandparent = u->getParent();
            Node *ul = u->getLeft();
            Node *ur = u->getRight();
            Node *vl = v->getLeft();
            Node *vr = v->getRight();
            bool vIsLeft = (u->getLeft() == v);

            // 1. Connect grandparent to v
            if (grandparent)
            {
                if (grandparent->getLeft() == u)
                    grandparent->setLeft(v);
                else
                    grandparent->setRight(v);
            }
            else
            {
                _root = v;
            }

            v->setParent(grandparent);
            u->setParent(v);

            // 2. Reassign child links
            if (vIsLeft)
            {
                v->setLeft(u);
                v->setRight(ur == v ? nullptr : ur);
                if (v->getRight())
                    v->getRight()->setParent(v);
            }
            else
            {
                v->setRight(u);
                v->setLeft(ul == v ? nullptr : ul);
                if (v->getLeft())
                    v->getLeft()->setParent(v);
            }

            // u adopts v’s previous children
            u->setLeft(vl == u ? nullptr : vl);
            u->setRight(vr == u ? nullptr : vr);
            if (u->getLeft())
                u->getLeft()->setParent(u);
            if (u->getRight())
                u->getRight()->setParent(u);

            return;
        }
        if (v == u->getParent())
        {
            // Just flip roles and reuse logic
            std::swap(u, v);
            // Now u is the parent and v is the child
            // Reuse same code block
            // Note: DON'T call swapRandomNodes() recursively; re-enter the block directly
            Node *grandparent = u->getParent();
            Node *ul = u->getLeft();
            Node *ur = u->getRight();
            Node *vl = v->getLeft();
            Node *vr = v->getRight();
            bool vIsLeft = (u->getLeft() == v);

            if (grandparent)
            {
                if (grandparent->getLeft() == u)
                    grandparent->setLeft(v);
                else
                    grandparent->setRight(v);
            }
            else
            {
                _root = v;
            }

            v->setParent(grandparent);
            u->setParent(v);

            if (vIsLeft)
            {
                v->setLeft(u);
                v->setRight(ur == v ? nullptr : ur);
                if (v->getRight())
                    v->getRight()->setParent(v);
            }
            else
            {
                v->setRight(u);
                v->setLeft(ul == v ? nullptr : ul);
                if (v->getLeft())
                    v->getLeft()->setParent(v);
            }

            u->setLeft(vl == u ? nullptr : vl);
            u->setRight(vr == u ? nullptr : vr);
            if (u->getLeft())
                u->getLeft()->setParent(u);
            if (u->getRight())
                u->getRight()->setParent(u);

            return;
        }
    }
    /////////////////// end conditions //////////////

    // if share the same parent, swap them in place
    // if ((u->getParent() == v->getParent())) return;
    if (u->getParent() == v->getParent())
    {
        Node *p = u->getParent();
        Node *ul = u->getLeft();
        Node *ur = u->getRight();
        Node *vl = v->getLeft();
        Node *vr = v->getRight();

        // Swap child pointers in parent
        if (p->getLeft() == u)
        {
            p->setLeft(v);
            p->setRight(u);
        }
        else
        {
            p->setLeft(u);
            p->setRight(v);
        }

        // Swap their children
        u->setLeft(vl);
        u->setRight(vr);
        v->setLeft(ul);
        v->setRight(ur);

        // Update parent of children
        if (u->getLeft())
            u->getLeft()->setParent(u);
        if (u->getRight())
            u->getRight()->setParent(u);
        if (v->getLeft())
            v->getLeft()->setParent(v);
        if (v->getRight())
            v->getRight()->setParent(v);

        // Keep parent unchanged
        u->setParent(p);
        v->setParent(p);

        return;
    }
    ///////////////// end conditions //////////////

    // in the same subtree
    // if (isDescendant(u, v) || isDescendant(v, u)) return;
    if (isDescendant(u, v) || isDescendant(v, u))
    {
        // Make sure u is the ancestor
        if (isDescendant(v, u))
            std::swap(u, v);

        Node *pu = u->getParent();
        Node *pv = v->getParent();

        Node *ul = u->getLeft();
        Node *ur = u->getRight();
        Node *vl = v->getLeft();
        Node *vr = v->getRight();

        bool uIsLeftChild = (pu && pu->getLeft() == u);
        bool vIsLeftChild = (pv && pv->getLeft() == v);

        // Step 1: Detach v from its parent
        if (pv)
        {
            if (vIsLeftChild)
                pv->setLeft(nullptr);
            else
                pv->setRight(nullptr);
        }

        // Step 2: Detach u from its parent
        if (pu)
        {
            if (uIsLeftChild)
                pu->setLeft(v);
            else
                pu->setRight(v);
        }
        else
        {
            _root = v; // v becomes new root
        }

        // Step 3: v takes u’s children (except v itself)
        if (ul != v)
            v->setLeft(ul);
        else
            v->setLeft(nullptr);
        if (ur != v)
            v->setRight(ur);
        else
            v->setRight(nullptr);
        if (v->getLeft())
            v->getLeft()->setParent(v);
        if (v->getRight())
            v->getRight()->setParent(v);
        v->setParent(pu);

        // Step 4: u moves to v’s position
        u->setParent(pv);
        if (vl != u)
            u->setLeft(vl);
        else
            u->setLeft(nullptr);
        if (vr != u)
            u->setRight(vr);
        else
            u->setRight(nullptr);
        if (u->getLeft())
            u->getLeft()->setParent(u);
        if (u->getRight())
            u->getRight()->setParent(u);

        if (pv)
        {
            if (vIsLeftChild)
                pv->setLeft(u);
            else
                pv->setRight(u);
        }

        return;
    }
    //////////////// end conditions //////////////

    ///////////// end of special cases /////////////

    //////////////// general case /////////////////
    // Save neighbors
    Node *pu = u->getParent();
    Node *pl = u->getLeft();
    Node *pr = u->getRight();

    Node *qv = v->getParent();
    Node *ql = v->getLeft();
    Node *qr = v->getRight();

    // Swap parents
    u->setParent(qv);
    v->setParent(pu);

    // Swap children
    u->setLeft(ql);
    u->setRight(qr);
    v->setLeft(pl);
    v->setRight(pr);

    // Fix parents’ child pointers
    if (qv)
    {
        if (qv->getLeft() == v)
            qv->setLeft(u);
        else if (qv->getRight() == v)
            qv->setRight(u);
    }
    else
    {
        _root = u; // v was root
    }

    if (pu)
    {
        if (pu->getLeft() == u)
            pu->setLeft(v);
        else if (pu->getRight() == u)
            pu->setRight(v);
    }
    else
    {
        _root = v; // u was root
    }

    // Fix children’s parent pointers
    if (ql)
        ql->setParent(u);
    if (qr)
        qr->setParent(u);
    if (pl)
        pl->setParent(v);
    if (pr)
        pr->setParent(v);
}

bool Tree::isDescendant(Node *ancestor, Node *candidate)
{
    if (!ancestor)
        return false;
    if (ancestor == candidate)
        return true;
    return isDescendant(ancestor->getLeft(), candidate) ||
           isDescendant(ancestor->getRight(), candidate);
}

void Tree::clearContour()
{
    ContourSegment *cur = _contourHead;
    while (cur)
    {
        ContourSegment *next = cur->next;
        delete cur;
        cur = next;
    }
    _contourHead = nullptr;
}

// void Tree::pack()
// {
//     clearContour();
//     _contourHead = new ContourSegment(0, std::numeric_limits<size_t>::max(), 0);
//     pack(_root, 0); // Start at origin
// }

// File: src/tree.cpp

void Tree::pack()
{
    clearContour();
    // flat ground contour
    _contourHead = new ContourSegment(0, std::numeric_limits<size_t>::max(), 0);
    pack(_root, 0);
}

// void Tree::pack(Node *node, size_t baseX)
// {
//     if (!node)
//         return;

//     Block &blk = _blocks[node->getBlockIndex()];
//     bool rotated = node->isRotated();
//     size_t width = blk.getWidth(rotated);
//     size_t height = blk.getHeight(rotated);

//     size_t baseY = findMaxY(baseX, baseX + width);

//     blk.setPos(baseX, baseY, baseX + width, baseY + height);

//     updateContour(baseX, baseX + width, baseY + height);

//     if (node->getLeft())
//     {
//         pack(node->getLeft(), baseX + width);
//     }

//     if (node->getRight())
//     {
//         pack(node->getRight(), baseX);
//     }
// }

void Tree::pack(Node *node, size_t baseX)
{
    if (!node)
        return;

    Block &blk = _blocks[node->getBlockIndex()];
    bool rotated = node->isRotated();
    size_t width = blk.getWidth(rotated);
    size_t height = blk.getHeight(rotated);

    // 1. Calculate Y position (safe even if width is 0)
    size_t baseY = findMaxY(baseX, baseX + width);

    // 2. Set position (if 0x0, x2=x1 and y2=y1, effectively a point)
    blk.setPos(baseX, baseY, baseX + width, baseY + height);

    // 3. ONLY update contour if the block actually takes up space
    if (width > 0 && height > 0)
    {
        updateContour(baseX, baseX + width, baseY + height);
    }

    // 4. Recurse (Standard B*-tree logic)
    // If width is 0, the Left Child will be packed at (baseX + 0) = baseX,
    // effectively "overlapping" the ghost but physically replacing it.
    if (node->getLeft())
    {
        pack(node->getLeft(), baseX + width);
    }

    if (node->getRight())
    {
        pack(node->getRight(), baseX);
    }
}

double Tree::findMaxY(size_t x1, size_t x2) const
{
    size_t maxY = 0;

    ContourSegment *cur = _contourHead;

    // Traverse until we find the first segment that overlaps with x1
    while (cur && cur->x_end <= x1)
    {
        cur = cur->next;
    }

    // Now process segments overlapping with [x1, x2)
    while (cur && cur->x_start < x2)
    {
        maxY = std::max(maxY, cur->height);
        cur = cur->next;
    }

    return maxY;
}

void Tree::updateContour(size_t x1, size_t x2, size_t newHeight)
{
    ContourSegment *cur = _contourHead;

    // Step 1: Traverse to first segment that may overlap with x1
    while (cur && cur->x_end <= x1)
    {
        cur = cur->next;
    }

    // Step 2: Split start if needed
    if (cur && cur->x_start < x1 && cur->x_end > x1)
    {
        // Split into [cur->x_start, x1) and [x1, cur->x_end)
        ContourSegment *left = new ContourSegment(cur->x_start, x1, cur->height);
        ContourSegment *right = new ContourSegment(x1, cur->x_end, cur->height);

        // Re-link
        left->prev = cur->prev;
        left->next = right;
        right->prev = left;
        right->next = cur->next;

        if (left->prev)
            left->prev->next = left;
        else
            _contourHead = left;

        if (right->next)
            right->next->prev = right;

        delete cur;
        cur = right;
    }

    // Step 3: Start deleting all segments fully within [x1, x2)
    while (cur && cur->x_start < x2)
    {
        ContourSegment *next = cur->next;

        // If this segment extends beyond x2, split it
        if (cur->x_end > x2)
        {
            ContourSegment *tail = new ContourSegment(x2, cur->x_end, cur->height);
            tail->next = cur->next;
            tail->prev = cur->prev;

            if (tail->next)
                tail->next->prev = tail;
            if (tail->prev)
                tail->prev->next = tail;
            else
                _contourHead = tail;

            delete cur;
            cur = nullptr;
            break;
        }

        // Remove cur from the list
        if (cur->prev)
            cur->prev->next = cur->next;
        else
            _contourHead = cur->next;

        if (cur->next)
            cur->next->prev = cur->prev;

        delete cur;
        cur = next;
    }

    // Step 4: Insert the new segment [x1, x2) with newHeight
    // Find insert position: after x1's previous segment
    ContourSegment *insertAfter = _contourHead;
    ContourSegment *prevNode = nullptr;
    while (insertAfter && insertAfter->x_start < x1)
    {
        prevNode = insertAfter;
        insertAfter = insertAfter->next;
    }

    ContourSegment *newSeg = new ContourSegment(x1, x2, newHeight);
    newSeg->prev = prevNode;
    newSeg->next = insertAfter;

    if (prevNode)
        prevNode->next = newSeg;
    else
        _contourHead = newSeg;

    if (insertAfter)
        insertAfter->prev = newSeg;
}

void Tree::checkContour() const
{
    ContourSegment *cur = _contourHead;
    cout << "==========================" << endl;
    cout << "Checking contour..." << endl;
    while (cur)
    {
        if (cur->x_start >= cur->x_end)
        {
            cout << "Invalid segment: [" << cur->x_start << ", " << cur->x_end << ")" << endl;
        }
        if (cur->next && cur->next->prev != cur)
        {
            cout << "Broken next-prev link at: [" << cur->x_start << ", " << cur->x_end << ")" << endl;
        }
        if (cur->prev && cur->prev->next != cur)
        {
            cout << "Broken prev-next link at: [" << cur->x_start << ", " << cur->x_end << ")" << endl;
        }
        cur = cur->next;
    }
    cout << "Contour check complete." << endl;
    cout << "==========================" << endl;
}

void Tree::printContour() const
{
    cout << "[Contour] ";
    size_t segCount = 0;
    ContourSegment *cur = _contourHead;
    while (cur)
    {
        segCount++;
        cout << "[" << cur->x_start << ", " << cur->x_end << ") @ height "
             << cur->height << "  ";
        cur = cur->next;
        cout << endl;
    }
    cout << "NULL" << endl;
    cout << "Total segments: " << segCount << endl;
}

// void Tree::printTree(Node* node, int depth) const {
//     if (!node) return;

//     string indent(depth * 2, ' ');  // 2 spaces per level
//     int id = node->getBlockIndex();
//     bool rotated = node->isRotated();
//     cout << indent << "Block " << id
//          << (rotated ? " (rotated)" : "")
//          << endl;

//     // Traverse children
//     printTree(node->getLeft(), depth + 1);   // left = to the right
//     printTree(node->getRight(), depth + 1);  // right = above
// }

void Tree::printTree(Node *node, int depth, int &count) const
{
    if (!node)
        return;
    ++count;

    string indent(depth * 2, ' ');
    // cout << indent << "Block " << node->getBlockIndex() << endl;
    cout << indent << "Block " << node->getBlockIndex() << endl;

    printTree(node->getLeft(), depth + 1, count);
    printTree(node->getRight(), depth + 1, count);
}

// void Tree::exportToFile(const string& filename) const {
//     ofstream fout(filename);
//     if (!fout.is_open()) {
//         cerr << "Cannot open output file: " << filename << endl;
//         return;
//     }

//     for (const Node& node : _nodes) {
//         const Block& blk = _blocks[node.getBlockIndex()];
//         fout << _blocks[node.getBlockIndex()].getName() << " "
//              << _blocks[node.getBlockIndex()].getX1() << " " << _blocks[node.getBlockIndex()].getY1() << " "
//              << _blocks[node.getBlockIndex()].getX2() << " " << _blocks[node.getBlockIndex()].getY2() << " "
//              << (node.isRotated() ? "rotated" : "normal") << endl;
//     }

//     fout.close();
// }

void Tree::exportToFile(fstream &output, size_t outlineW, size_t outlineH, const std::chrono::milliseconds &duration, size_t outputCost, size_t outputWL, size_t outputArea, size_t maxX, size_t maxY) const
{
    // std::ofstream fout(filename);
    if (!output.is_open())
    {
        std::cerr << "Cannot open output file" << std::endl;
        return;
    }

    // output << "OUTLINE " << outlineW << " " << outlineH << "\n";

    // cost
    output << outputCost << "\n";
    // wirelength
    output << outputWL << "\n";
    // area
    output << outputArea << "\n";
    // width and height
    output << maxX << " " << maxY << "\n";
    // duration
    output << duration.count() * 0.001 << "\n";

    for (const Node &node : _nodes)
    {
        Block &blk = _blocks[node.getBlockIndex()];
        output << blk.getName() << " "
               << blk.getX1() << " " << blk.getY1() << " "
               << blk.getX2() << " " << blk.getY2() << "\n";
        //  << (node.isRotated() ? "rotated" : "normal") << "\n";
    }

    output.close();
}

void Tree::exportToFile_visualize(fstream &output, size_t outlineW, size_t outlineH, const std::chrono::milliseconds &duration, size_t outputCost, size_t outputWL, size_t outputArea, size_t maxX, size_t maxY) const
{
    // std::ofstream fout(filename);
    if (!output.is_open())
    {
        std::cerr << "Cannot open output file" << std::endl;
        return;
    }

    output << "OUTLINE " << outlineW << " " << outlineH << "\n";

    // cost
    output << outputCost << "\n";
    // wirelength
    output << outputWL << "\n";
    // area
    output << outputArea << "\n";
    // width and height
    output << maxX << " " << maxY << "\n";
    // duration
    output << duration.count() * 0.001 << "\n";

    for (const Node &node : _nodes)
    {
        Block &blk = _blocks[node.getBlockIndex()];
        output << blk.getName() << " "
               << blk.getX1() << " " << blk.getY1() << " "
               << blk.getX2() << " " << blk.getY2() << "\n";
        //  << (node.isRotated() ? "rotated" : "normal") << "\n";
    }

    output.close();
}


==============================================================================
File: src/tree.h
==============================================================================
#ifndef TREE_H
#define TREE_H

#include <vector>
#include <cstdlib> // for rand()
#include "node.h"
#include "module.h" // Block, Terminal, Net
#include <chrono>

using namespace std;

class Tree
{
public:
    Tree(vector<Block> &blocks)
        : _blocks(blocks), _root(nullptr), _contourHead(nullptr)
    {
        // _nodes.reserve(blocks.size()); // Reserve space for nodes
        // for (size_t i = 0; i < blocks.size(); ++i) {
        //     _nodes.emplace_back(i); // equals to _nodes.push_back(Node(i))
        // }
    }

    void buildInitial();                                // trivial B*-tree construction (e.g. linear left-chain)
    void rotateRandom();                                // perturbation 1
    void deleteAndInsert();                             // perturbation 2
    void swapRandomNodes();                             // perturbation 3
    void resizeRandom();                                // perturbation 4 for soft modules
    bool isDescendant(Node *ancestor, Node *candidate); // check if candidate is a descendant of ancestor
    Node *buildBalancedRecursive(int l, int r);         // build a balanced tree recursively

    // packing related functions
    void pack();                                             // compute (x1, y1, x2, y2) for each block
    double findMaxY(size_t x1, size_t x2) const;             // find max y in contour between x1 and x2
    void updateContour(size_t x1, size_t x2, size_t height); // update contour after placing a block
    void clearContour();                                     // clear the contour list
    void printContour() const;                               // print the contour for debugging
    void checkContour() const;                               // check the contour for debugging

    Node *getRoot() const { return _root; }
    const vector<Node> &getNodes() const { return _nodes; }

    /// Print the B*-tree structure
    void printTree(Node *node, int depth, int &count) const;
    int getNumofNodes() const { return _nodes.size(); }

    void setFixedModules(const vector<Block> *fixed)
    {
        _fixed_modules = fixed;
    }

    // horizontal segment of the contour
    struct ContourSegment
    {
        size_t x_start, x_end; // horizontal range
        size_t height;         // top y of the segment
        ContourSegment *prev;
        ContourSegment *next;

        ContourSegment(size_t x1, size_t x2, size_t h)
            : x_start(x1), x_end(x2), height(h), prev(nullptr), next(nullptr) {}
    };

    // visualization function (for debugging)
    // void exportToFile(const string& filename) const;

    void exportToFile(fstream &output, size_t outlineW, size_t outlineH, const std::chrono::milliseconds &duration, size_t outputCost, size_t outputWL, size_t outputArea, size_t maxX, size_t maxY) const;
    void exportToFile_visualize(fstream &output, size_t outlineW, size_t outlineH, const std::chrono::milliseconds &duration, size_t outputCost, size_t outputWL, size_t outputArea, size_t maxX, size_t maxY) const;

    Tree &operator=(const Tree &other)
    {
        if (this != &other)
        {
            // Reuse the existing _blocks reference
            _nodes = other._nodes;
            _root = nullptr;

            // Reconnect pointers in _nodes
            for (size_t i = 0; i < _nodes.size(); ++i)
            {
                if (other._nodes[i].getParent())
                    _nodes[i].setParent(&_nodes[other._nodes[i].getParent()->getBlockIndex()]);
                if (other._nodes[i].getLeft())
                    _nodes[i].setLeft(&_nodes[other._nodes[i].getLeft()->getBlockIndex()]);
                if (other._nodes[i].getRight())
                    _nodes[i].setRight(&_nodes[other._nodes[i].getRight()->getBlockIndex()]);
            }

            // Restore root
            if (other._root)
                _root = &_nodes[other._root->getBlockIndex()];
        }
        return *this;
    }

private:
    vector<Node> _nodes;    // One node per block (1-1 mapping by index)
    Node *_root;            // root of the B*-tree
    vector<Block> &_blocks; // Reference to external block array

    void pack(Node *v, size_t baseX); // internal recursive function

    void deleteNode(Node *u);                                 // helper: remove a node from the tree
    void insertNode(Node *u, Node *target, bool asLeftChild); // helper: insert node into new location

    ContourSegment *_contourHead; // head of the contour list
    const vector<Block> *_fixed_modules = nullptr;
};

#endif // TREE_H



